#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';

const BASE_URL =
  (process.env.OPENROUTER_API_BASE_URL || 'https://openrouter.ai/api/v1').replace(
    /\/$/,
    ''
  );
const API_KEY = process.env.OPENROUTER_API_KEY || process.env.OPENROUTER_KEY || '';
const OUTPUT_FILE = path.resolve(
  process.cwd(),
  'src/generated/openrouterFallbackModels.ts'
);

function normalizeStringList(value) {
  if (!Array.isArray(value)) return [];
  return value
    .filter((item) => typeof item === 'string')
    .map((item) => item.trim())
    .filter(Boolean);
}

function getBooleanFlag(value) {
  return typeof value === 'boolean' ? value : undefined;
}

function isEmbeddingModelRecord(model) {
  const id = String(model?.id ?? '').toLowerCase();
  const name = String(model?.name ?? '').toLowerCase();
  if (id.includes('embedding') || id.includes('embed')) return true;
  if (name.includes('embedding') || name.includes('embed')) return true;

  const supportedParameters = normalizeStringList(
    model?.supported_parameters ?? model?.supportedParameters ?? model?.parameters
  ).map((param) => param.toLowerCase());
  if (supportedParameters.includes('embeddings') || supportedParameters.includes('embedding')) {
    return true;
  }

  const architecture = model?.architecture;
  if (architecture && typeof architecture === 'object') {
    const outputModalities = normalizeStringList(
      architecture.output_modalities ?? architecture.outputModalities
    ).map((value) => value.toLowerCase());
    if (outputModalities.includes('embeddings') || outputModalities.includes('embedding')) {
      return true;
    }
  }

  return false;
}

function toModel(model) {
  if (!model || typeof model !== 'object') return null;
  const id = typeof model.id === 'string' ? model.id : '';
  if (!id) return null;
  const name = typeof model.name === 'string' && model.name ? model.name : id;

  const supportedParameters = normalizeStringList(
    model.supported_parameters ?? model.supportedParameters ?? model.parameters
  );
  const normalizedParams = supportedParameters.map((param) => param.toLowerCase());
  const tags = normalizeStringList(model.tags ?? model.tag).map((tag) => tag.toLowerCase());
  const capabilitiesRaw = model.capabilities ?? model.capability ?? model.features;
  const capabilities = normalizeStringList(capabilitiesRaw).map((value) =>
    value.toLowerCase()
  );
  const explicitReasoning = getBooleanFlag(
    model.supports_reasoning ?? model.supportsReasoning
  );
  const capabilityReasoning =
    typeof capabilitiesRaw === 'object' &&
    capabilitiesRaw !== null &&
    getBooleanFlag(capabilitiesRaw.reasoning) === true;
  const supportsReasoning =
    typeof explicitReasoning === 'boolean'
      ? explicitReasoning
      : normalizedParams.some((param) => param === 'reasoning' || param === 'reasoning_effort') ||
        [...tags, ...capabilities].some((tag) => tag === 'reasoning' || tag === 'thinking') ||
        capabilityReasoning;

  const promptPrice = Number(model?.pricing?.prompt);
  const completionPrice = Number(model?.pricing?.completion);
  const contextLength = Number(model.context_length);

  return {
    id,
    name,
    contextLength: Number.isFinite(contextLength) && contextLength > 0 ? contextLength : 4096,
    pricing: {
      prompt: Number.isFinite(promptPrice) ? promptPrice : 0,
      completion: Number.isFinite(completionPrice) ? completionPrice : 0,
    },
    supportedParameters,
    supportsReasoning,
  };
}

function extractList(payload) {
  if (!payload || typeof payload !== 'object') return [];
  const data = payload.data;
  if (!Array.isArray(data)) return [];
  return data.filter((item) => item && typeof item === 'object');
}

async function fetchJson(endpoint) {
  const headers = {};
  if (API_KEY) headers.Authorization = `Bearer ${API_KEY}`;
  const response = await fetch(`${BASE_URL}${endpoint}`, { headers });
  if (!response.ok) {
    throw new Error(`${endpoint} -> ${response.status} ${response.statusText}`);
  }
  return response.json();
}

function dedupeAndSort(models) {
  const map = new Map();
  for (const model of models) {
    if (!model?.id) continue;
    map.set(model.id, model);
  }
  return [...map.values()].sort((a, b) => a.name.localeCompare(b.name));
}

function serializeModels(models) {
  return JSON.stringify(models, null, 2);
}

function buildSource(models, embeddingModels) {
  const generatedAt = new Date().toISOString();
  return `import type { LLMModel } from '../types';

// Generated by scripts/snapshot-openrouter-models.mjs
// Source: ${BASE_URL}
export const OPENROUTER_FALLBACK_GENERATED_AT = '${generatedAt}';

export const OPENROUTER_FALLBACK_MODELS: LLMModel[] = ${serializeModels(models)};

export const OPENROUTER_FALLBACK_EMBEDDING_MODELS: LLMModel[] = ${serializeModels(
    embeddingModels
  )};
`;
}

async function main() {
  try {
    const modelsPayload = await fetchJson('/models');
    const rawModels = extractList(modelsPayload);
    const models = dedupeAndSort(rawModels.map(toModel).filter(Boolean));

    let embeddingRaw = [];
    try {
      const embeddingsPayload = await fetchJson('/embeddings/models');
      embeddingRaw = extractList(embeddingsPayload);
    } catch (error) {
      console.warn(
        `[snapshot-openrouter-models] Could not fetch /embeddings/models: ${String(error)}`
      );
    }

    const embeddingCandidates =
      embeddingRaw.length > 0 ? embeddingRaw : rawModels.filter(isEmbeddingModelRecord);
    const embeddingModels = dedupeAndSort(
      embeddingCandidates.map(toModel).filter(Boolean)
    );

    if (models.length === 0) {
      throw new Error('OpenRouter /models returned no models');
    }

    const source = buildSource(models, embeddingModels);
    await fs.writeFile(OUTPUT_FILE, source, 'utf8');

    console.log(
      `[snapshot-openrouter-models] Updated ${OUTPUT_FILE} with ${models.length} models and ${embeddingModels.length} embedding models.`
    );
  } catch (error) {
    try {
      await fs.access(OUTPUT_FILE);
      console.warn(
        `[snapshot-openrouter-models] Failed to refresh snapshot, keeping existing file: ${String(
          error
        )}`
      );
      process.exit(0);
    } catch {
      console.error(`[snapshot-openrouter-models] ${String(error)}`);
      process.exit(1);
    }
  }
}

await main();
